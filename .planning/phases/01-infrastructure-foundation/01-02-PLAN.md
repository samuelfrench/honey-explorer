---
plan: 01-02
title: Fly.io Deployment and CI/CD Pipeline
phase: 1
wave: 2
depends_on: ["01-01"]
files_modified:
  - Dockerfile
  - fly.toml
  - start.sh
  - .github/workflows/deploy.yml
  - backend/src/main/resources/application-prod.properties
autonomous: false
---

# Plan 01-02: Fly.io Deployment and CI/CD Pipeline

## Objective

Deploy the scaffolded application to Fly.io with PostgreSQL database, and configure GitHub Actions to automatically deploy on push to main branch.

## Context

This plan builds on 01-01 (project scaffolding) and deploys the working application to production. We follow the cigar-explorer deployment pattern:
- Multi-stage Dockerfile: Maven build -> Node build -> Runtime with Nginx + Java
- Single Fly.io machine running both Nginx (frontend) and Spring Boot (backend)
- Fly Postgres for production database
- GitHub Actions workflow for CI/CD

Prerequisites from 01-01:
- Backend builds with `mvn clean package`
- Frontend builds with `npm run build`
- Health endpoint at `/api/health`

Reference: `/home/sam/claude-workspace/cigar-explorer/Dockerfile`, `fly.toml`, `start.sh`

## Tasks

<task id="1">
**Create Dockerfile for multi-stage build**

Create `Dockerfile` at project root following cigar-explorer pattern:

Stage 1 - Backend Build:
- Base: `maven:3.9-eclipse-temurin-21-alpine`
- Copy `backend/pom.xml`, run `mvn dependency:go-offline`
- Copy `backend/src`, run `mvn clean package -DskipTests`

Stage 2 - Frontend Build:
- Base: `node:20-alpine`
- Copy `frontend/package*.json`, run `npm ci`
- Copy `frontend/`, run `npm run build`

Stage 3 - Runtime:
- Base: `eclipse-temurin:21-jre-alpine`
- Install nginx
- Copy JAR from backend-build stage to `/app/app.jar`
- Copy frontend dist from frontend-build stage to `/usr/share/nginx/html`
- Copy `frontend/nginx.conf` to `/etc/nginx/conf.d/default.conf`
- Write nginx main config (worker processes, http block, includes)
- Copy and chmod `start.sh`
- Expose port 80
- CMD: `/start.sh`
</task>

<task id="2">
**Create start.sh startup script**

Create `start.sh` at project root:

1. Parse DATABASE_URL from Fly.io format (postgres://user:pass@host:port/db) to JDBC format:
   - Extract user, password, host:port/db
   - Set `SPRING_DATASOURCE_URL=jdbc:postgresql://host:port/db`
   - Set `SPRING_DATASOURCE_USERNAME` and `SPRING_DATASOURCE_PASSWORD`

2. Start Java application in background:
   - Use flags: `-Xmx512m -XX:+UseContainerSupport -XX:MaxRAMPercentage=75.0`
   - Set active profile: `-Dspring.profiles.active=prod`
   - Run JAR: `/app/app.jar`
   - Capture PID

3. Wait for backend to start (sleep 5-10 seconds)

4. Start Nginx in foreground:
   - `exec nginx -g 'daemon off;'`

Reference: `/home/sam/claude-workspace/cigar-explorer/start.sh`
</task>

<task id="3">
**Create production application properties**

Create `backend/src/main/resources/application-prod.properties`:

1. Database configuration:
   - Datasource URL, username, password will come from environment variables
   - `spring.datasource.url=${SPRING_DATASOURCE_URL}`
   - `spring.datasource.username=${SPRING_DATASOURCE_USERNAME}`
   - `spring.datasource.password=${SPRING_DATASOURCE_PASSWORD}`

2. JPA settings for production:
   - `spring.jpa.hibernate.ddl-auto=validate` (Flyway manages schema)
   - `spring.jpa.show-sql=false`

3. Flyway settings:
   - `spring.flyway.enabled=true`
   - `spring.flyway.locations=classpath:db/migration`
</task>

<task id="4">
**Create fly.toml configuration**

Create `fly.toml` at project root:

```toml
app = 'honey-explorer'
primary_region = 'dfw'

[build]

[http_service]
  internal_port = 80
  force_https = true
  auto_stop_machines = 'stop'
  auto_start_machines = true
  min_machines_running = 1
  processes = ['app']

[[vm]]
  memory = '1gb'
  cpu_kind = 'shared'
  cpus = 1
```

Notes:
- 1GB memory for JVM + Nginx (Java needs at least 512MB)
- DFW region (Dallas) for low latency
- Auto-stop to save costs when idle
- Min 1 machine running for availability
</task>

<task id="5">
**Deploy to Fly.io and provision PostgreSQL**

This task requires CLI commands. The executor should:

1. Ensure Fly CLI is authenticated (`fly auth login` if needed)

2. Create the Fly.io app:
   ```bash
   cd /home/sam/claude-workspace/honey-explorer
   fly apps create honey-explorer --org personal
   ```
   (If app name taken, use `honey-explorer-<random>` and update fly.toml)

3. Create Fly Postgres database:
   ```bash
   fly postgres create --name honey-explorer-db --region dfw --vm-size shared-cpu-1x --volume-size 1
   ```

4. Attach database to app:
   ```bash
   fly postgres attach honey-explorer-db --app honey-explorer
   ```
   This sets DATABASE_URL secret automatically.

5. Deploy the application:
   ```bash
   fly deploy
   ```

6. Verify deployment:
   ```bash
   fly status
   curl -s https://honey-explorer.fly.dev/api/health
   ```
   Should return `{"status":"healthy",...}`

7. Check logs if issues:
   ```bash
   fly logs
   ```
</task>

<task id="6">
**Create GitHub Actions CI/CD workflow**

Create `.github/workflows/deploy.yml`:

```yaml
name: Deploy to Fly.io

on:
  push:
    branches:
      - main
  workflow_dispatch:

jobs:
  deploy:
    name: Deploy
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Fly CLI
        uses: superfly/flyctl-actions/setup-flyctl@master

      - name: Deploy to Fly.io
        run: flyctl deploy --remote-only
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
```

After creating the file:
1. Generate Fly.io API token: `fly tokens create deploy -x 999999h`
2. Add token as GitHub secret named `FLY_API_TOKEN`
3. Push to main branch to trigger deployment
</task>

<task id="7" type="checkpoint:human-verify">
**Verify production deployment**

After deployment completes, verify the following:

1. Visit https://honey-explorer.fly.dev (or the actual deployed URL)
   - Page should load showing "Honey Explorer"
   - Health status should show "healthy"

2. Check API directly:
   ```bash
   curl https://honey-explorer.fly.dev/api/health
   ```
   - Should return: `{"status":"healthy","timestamp":"..."}`

3. Check Fly.io dashboard:
   - App is running (green status)
   - Database is attached and healthy

4. Verify GitHub Actions:
   - Push a small change to main
   - Verify the deploy workflow runs successfully
   - Verify the change appears on the live site

If any issues, check `fly logs` for errors.
</task>

## Verification

Run these commands to verify the plan succeeded:

```bash
# Verify Dockerfile builds locally (optional, Fly.io builds remotely)
cd /home/sam/claude-workspace/honey-explorer
docker build -t honey-explorer-test .
# Expected: Build completes successfully

# Verify Fly.io app is running
fly status --app honey-explorer
# Expected: Shows "running" state

# Verify health endpoint on production
curl -s https://honey-explorer.fly.dev/api/health | jq .
# Expected: {"status":"healthy","timestamp":"..."}

# Verify database is attached
fly postgres list
# Expected: Shows honey-explorer-db

# Verify GitHub Actions workflow exists
cat .github/workflows/deploy.yml
# Expected: Shows deploy workflow configuration
```

## Must-Haves

- [ ] `Dockerfile` exists with 3-stage build (Maven, Node, Runtime)
- [ ] `start.sh` exists and converts DATABASE_URL to JDBC format, starts Java + Nginx
- [ ] `fly.toml` exists with app name `honey-explorer`, 1GB memory, DFW region
- [ ] `backend/src/main/resources/application-prod.properties` exists with production DB config
- [ ] Fly.io app `honey-explorer` is created and running
- [ ] Fly Postgres database is provisioned and attached to app
- [ ] `https://honey-explorer.fly.dev/api/health` returns `{"status":"healthy",...}`
- [ ] `https://honey-explorer.fly.dev` loads the React frontend
- [ ] `.github/workflows/deploy.yml` exists with Fly.io deploy job
- [ ] `FLY_API_TOKEN` secret is configured in GitHub repository
- [ ] Push to main branch triggers successful deployment via GitHub Actions
